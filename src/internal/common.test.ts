import { expect } from "chai";
import { PoolInfo, PoolType, FeeDirection, WeeklyStandardMovingAverage } from "./common";
import { debugLog } from "./debug";
import { bigintPow } from "./utils";

interface PoolInfoDataType {
    fee_direction: FeeDirection;
    direction: "x-to-y" | "y-to-x";
    pool_x: string;
    pool_y: string;
    pool_admin_fee: string;
    pool_connect_fee: string;
    pool_lp_fee: string;
    pool_incentive_fee: string;
    x: string;
    y: string;
};

interface StablePoolInfoDataType {
    x_decimal: number;
    y_decimal: number;
    amp: number;
    data: [
        { tag: number, index: number, x_prev: string, x: string, y_prev: string, y: string, lsp_prev: string, lsp: string, pn: string, pd: string; }
    ]
}

describe('PoolInfo', () => { // the tests container
    it('checking swapXToYAmount and swapYToXAmount', () => {
        // The data is generated by the amm simulation backtesting in "aptoswap" written in (pool_test.move);
        // The original genearted python script for this is "suiwap/develop/scripts/amm_simulation.py"
        const poolInfoData = require("../../data/tests/pool_data_1.json") as Array<PoolInfoDataType>

        for (const info of poolInfoData) {
            const pool = new PoolInfo({
                type: {} as PoolType,
                typeString: "",
                addr: "",

                index: 0,
                swapType: "v2",

                x: BigInt(info.pool_x),
                y: BigInt(info.pool_y),
                lspSupply: BigInt(0),

                feeDirection: info.fee_direction,

                stableAmp: BigInt(0),
                stableXScale: BigInt(0),
                stableYScale: BigInt(0),

                freeze: false,
                lastTradeTime: Number(0),

                totalTradeX: BigInt(0),
                totalTradeY: BigInt(0),
                totalTrade24hLastCaptureTime: Number(0),
                totalTradeX24h: BigInt(0),
                totalTradeY24h: BigInt(0),

                kspSma: WeeklyStandardMovingAverage.Zero(),

                adminFee: BigInt(info.pool_admin_fee),
                lpFee: BigInt(info.pool_lp_fee),
                incentiveFee: BigInt(info.pool_incentive_fee),
                connectFee: BigInt(info.pool_connect_fee),
                withdrawFee: BigInt(0)
            });

            try {
                let inAmount = BigInt(0)
                let outAmount = BigInt(0);
                let outAmountExpected = BigInt(0);
                if (info.direction == "x-to-y") {
                    inAmount = BigInt(info.x);
                    outAmount = pool.getXToYAmount(inAmount);
                    outAmountExpected = BigInt(info.y);
    
                    expect(outAmount).equals(outAmountExpected)
                }
                else if (info.direction == "y-to-x") {
                    inAmount = BigInt(info.y);
                    outAmount = pool.getYToXAmount(inAmount);
                    outAmountExpected = BigInt(info.x);
    
                    expect(outAmount).equals(outAmountExpected)
                }
            } catch (e) {
                debugLog({ info: info, pool: pool });
                throw e;
            }
        }
    });

    it('checking swapXToYAmount and swapYToXAmount [stable]', () => {
        // { "tag": 1, "index": 2, "x_prev": "9955414196461476", "x": "9965309718209943", "y_prev": "1549963930764", "y": "1551504570006", "lsp_prev": "127243862962632", "lsp": "127370341317848", "pn": "1729974528723376726542642700940000", "pd": "1725660377778971886171539949523007"},
        const poolInfoData = require("../../data/tests/stablepool_data_1.json") as StablePoolInfoDataType;

        const xd = poolInfoData.x_decimal;
        const yd = poolInfoData.y_decimal;
        const md = Math.max(xd, yd);

        const pool = new PoolInfo({
            type: {} as PoolType,
            typeString: "",
            addr: "",

            index: 0,
            swapType: "stable",

            x: BigInt(poolInfoData.data[0].x),
            y: BigInt(poolInfoData.data[0].y),
            lspSupply: BigInt(0),

            feeDirection: "X",

            stableAmp: BigInt(poolInfoData.amp),
            stableXScale: bigintPow(BigInt(10), md - xd),
            stableYScale: bigintPow(BigInt(10), md - yd),

            freeze: false,
            lastTradeTime: Number(0),

            totalTradeX: BigInt(0),
            totalTradeY: BigInt(0),
            totalTrade24hLastCaptureTime: Number(0),
            totalTradeX24h: BigInt(0),
            totalTradeY24h: BigInt(0),

            kspSma: WeeklyStandardMovingAverage.Zero(),

            adminFee: BigInt(0),
            lpFee: BigInt(0),
            incentiveFee: BigInt(0),
            connectFee: BigInt(0),
            withdrawFee: BigInt(0)
        }); 
        
        for (const info of poolInfoData.data.slice(1)) {
            if (info.tag != 0) {
                continue;
            }

            const xPrev = BigInt(info.x_prev);
            const yPrev = BigInt(info.y_prev);
            const x = BigInt(info.x);
            const y = BigInt(info.y);

            try {
                pool.x = xPrev;
                pool.y = yPrev;

                let outAmount = BigInt(0);
                let outAmountExpected = BigInt(0);

                if (x >= xPrev) {
                    let inAmount = x - xPrev;
                    outAmount = pool.getXToYAmount(inAmount);
                    outAmountExpected = yPrev - y;
                    expect(outAmount).equals(outAmountExpected)
                }
                else if (y > yPrev) {
                    const inAmount = y - yPrev;
                    outAmount = pool.getYToXAmount(inAmount);
                    outAmountExpected = xPrev - x;
                    expect(outAmount).equals(outAmountExpected)
                }
            } catch (e) {
                debugLog({ info: info, pool: pool });
                throw e;
            }

            pool.x = x;
            pool.y = y;

            const [pn, pd] = pool._getPriceStableRational(poolInfoData.x_decimal, poolInfoData.y_decimal);
            expect(pn * BigInt(info.pd)).equals(pd * BigInt(info.pn));
        }
    });
});